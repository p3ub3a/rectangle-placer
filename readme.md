### Rectangle placement

#### Description:
Given a set of rectangles in which the area of the i-th one is given by Ai. Write a parallel program to position the rectangles in a large rectangle, subject to the conditions that:

1. The individual rectangles must not overlap.
2. All n smaller rectangles must be included in the large one.
3. The area of the larger one is to be a minimum

#### Proposed solution:
First-Fit Decreasing Height (**FFDH**) algorithm:
FFDH packs the next item R (in non-increasing height) on the first level where R fits. If no level can accommodate R, a new level is created.

Time complexity of FFDH: O(nÂ·log n).

#### Code dive:

After starting the program, the user can specify the **number of threads** (that should work on packing the rectangles) and 
the **number of rectangles** to be placed. 

Clicking *Generate* will run the algorithm.

After the canvas is populated with rectangles, the execution time in *ms* is shown.

##### Steps

* to work with multiple threads, I used Java's **ExecutorService** interface and I initialized the thread pool to the number of threads given as an input;
* the rectangles are randomly generated by **generateRectangles**, they have different sizes which can be changed by modifying **Constants.java**. Here the rectangles are also sorted by decreasing height;
* in order to avoid resource sharing among threads, I created **linesDeque** queue which contains lists of rectangles to be sorted. 
Each thread will work on a different set of rectangles. This happens in **splitWork(threadNr)**;
* the actual rectangle placement takes place inside **placeRectangles()**, where each thread takes a rectangle list from **linesDeque** and sets the position for the rectangles.
**futureMessage.get();** waits for the thread to finish the job;
* each thread calls **processLine(retrievedRectangles)**. At this point retrievedRectangles are already sorted by descending height. 
This is where the lightweight process goes through each rectangle and tries to find a line with enough width remaining to fit a new rectangle.
If no line is found, a new one is created and the rectangle will be placed there in a future iteration;
* rectangle placement (setting the x,y coordinates) is synchronized in order to avoid multiple threads placing rectangles in the same spot;
* in the end, the ExecutorService is shutdown by calling **awaitTerminationAfterShutdown(rectangleService)**.

##### User interface
* *RectangleCanvas* is a **JFrame** which encapsulates a **JPanel** named *SettingsPanel* and  a **JComponent** that draws the rectangles;
* *SettingsPanel* contains 2 input fields for thread number and rectangles number, a generate button and a running time label.
